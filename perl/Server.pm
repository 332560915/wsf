# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.35
#
# Don't modify this file, modify the SWIG interface instead.

package WSO2::WSF::Server;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package WSO2::WSF::Serverc;
bootstrap WSO2::WSF::Server;
package WSO2::WSF::Server;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package WSO2::WSF::Server;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package WSO2::WSF::Server;

*wsf_axutil_strdup = *WSO2::WSF::Serverc::wsf_axutil_strdup;
*wsf_init = *WSO2::WSF::Serverc::wsf_init;
*wsf_env_create = *WSO2::WSF::Serverc::wsf_env_create;
*wsf_xml_msg_recv_create = *WSO2::WSF::Serverc::wsf_xml_msg_recv_create;
*axiom_xml_reader_init = *WSO2::WSF::Serverc::axiom_xml_reader_init;
*wsf_worker_create = *WSO2::WSF::Serverc::wsf_worker_create;
*wsf_get_worker = *WSO2::WSF::Serverc::wsf_get_worker;
*wsf_worker_get_conf_ctx = *WSO2::WSF::Serverc::wsf_worker_get_conf_ctx;
*wsf_worker_process_request = *WSO2::WSF::Serverc::wsf_worker_process_request;
*wsf_get_env = *WSO2::WSF::Serverc::wsf_get_env;

############# Class : WSO2::WSF::Server::wsf_svc_info_t ##############

package WSO2::WSF::Server::wsf_svc_info_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( WSO2::WSF::Server );
%OWNER = ();
%ITERATORS = ();
*swig_svc_get = *WSO2::WSF::Serverc::wsf_svc_info_t_svc_get;
*swig_svc_set = *WSO2::WSF::Serverc::wsf_svc_info_t_svc_set;
*swig_msg_recv_get = *WSO2::WSF::Serverc::wsf_svc_info_t_msg_recv_get;
*swig_msg_recv_set = *WSO2::WSF::Serverc::wsf_svc_info_t_msg_recv_set;
*swig_perl_worker_get = *WSO2::WSF::Serverc::wsf_svc_info_t_perl_worker_get;
*swig_perl_worker_set = *WSO2::WSF::Serverc::wsf_svc_info_t_perl_worker_set;
*swig_ops_to_actions_get = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_actions_get;
*swig_ops_to_actions_set = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_actions_set;
*swig_ops_to_functions_get = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_functions_get;
*swig_ops_to_functions_set = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_functions_set;
*swig_modules_to_engage_get = *WSO2::WSF::Serverc::wsf_svc_info_t_modules_to_engage_get;
*swig_modules_to_engage_set = *WSO2::WSF::Serverc::wsf_svc_info_t_modules_to_engage_set;
*swig_ops_to_classes_get = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_classes_get;
*swig_ops_to_classes_set = *WSO2::WSF::Serverc::wsf_svc_info_t_ops_to_classes_set;
*swig_request_xop_get = *WSO2::WSF::Serverc::wsf_svc_info_t_request_xop_get;
*swig_request_xop_set = *WSO2::WSF::Serverc::wsf_svc_info_t_request_xop_set;
*swig_use_mtom_get = *WSO2::WSF::Serverc::wsf_svc_info_t_use_mtom_get;
*swig_use_mtom_set = *WSO2::WSF::Serverc::wsf_svc_info_t_use_mtom_set;
*swig_svc_name_get = *WSO2::WSF::Serverc::wsf_svc_info_t_svc_name_get;
*swig_svc_name_set = *WSO2::WSF::Serverc::wsf_svc_info_t_svc_name_set;
*swig_port_name_get = *WSO2::WSF::Serverc::wsf_svc_info_t_port_name_get;
*swig_port_name_set = *WSO2::WSF::Serverc::wsf_svc_info_t_port_name_set;
*swig_generated_svc_name_get = *WSO2::WSF::Serverc::wsf_svc_info_t_generated_svc_name_get;
*swig_generated_svc_name_set = *WSO2::WSF::Serverc::wsf_svc_info_t_generated_svc_name_set;
*swig_op_name_get = *WSO2::WSF::Serverc::wsf_svc_info_t_op_name_get;
*swig_op_name_set = *WSO2::WSF::Serverc::wsf_svc_info_t_op_name_set;
sub new {
    my $pkg = shift;
    my $self = WSO2::WSF::Serverc::new_wsf_svc_info_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        WSO2::WSF::Serverc::delete_wsf_svc_info_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : WSO2::WSF::Server::wsf_req_info_t ##############

package WSO2::WSF::Server::wsf_req_info_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( WSO2::WSF::Server );
%OWNER = ();
%ITERATORS = ();
*swig_svr_port_get = *WSO2::WSF::Serverc::wsf_req_info_t_svr_port_get;
*swig_svr_port_set = *WSO2::WSF::Serverc::wsf_req_info_t_svr_port_set;
*swig_svr_name_get = *WSO2::WSF::Serverc::wsf_req_info_t_svr_name_get;
*swig_svr_name_set = *WSO2::WSF::Serverc::wsf_req_info_t_svr_name_set;
*swig_http_protocol_get = *WSO2::WSF::Serverc::wsf_req_info_t_http_protocol_get;
*swig_http_protocol_set = *WSO2::WSF::Serverc::wsf_req_info_t_http_protocol_set;
*swig_content_encoding_get = *WSO2::WSF::Serverc::wsf_req_info_t_content_encoding_get;
*swig_content_encoding_set = *WSO2::WSF::Serverc::wsf_req_info_t_content_encoding_set;
*swig_soap_action_get = *WSO2::WSF::Serverc::wsf_req_info_t_soap_action_get;
*swig_soap_action_set = *WSO2::WSF::Serverc::wsf_req_info_t_soap_action_set;
*swig_request_uri_get = *WSO2::WSF::Serverc::wsf_req_info_t_request_uri_get;
*swig_request_uri_set = *WSO2::WSF::Serverc::wsf_req_info_t_request_uri_set;
*swig_query_string_get = *WSO2::WSF::Serverc::wsf_req_info_t_query_string_get;
*swig_query_string_set = *WSO2::WSF::Serverc::wsf_req_info_t_query_string_set;
*swig_content_length_get = *WSO2::WSF::Serverc::wsf_req_info_t_content_length_get;
*swig_content_length_set = *WSO2::WSF::Serverc::wsf_req_info_t_content_length_set;
*swig_content_type_get = *WSO2::WSF::Serverc::wsf_req_info_t_content_type_get;
*swig_content_type_set = *WSO2::WSF::Serverc::wsf_req_info_t_content_type_set;
*swig_request_method_get = *WSO2::WSF::Serverc::wsf_req_info_t_request_method_get;
*swig_request_method_set = *WSO2::WSF::Serverc::wsf_req_info_t_request_method_set;
*swig_req_data_get = *WSO2::WSF::Serverc::wsf_req_info_t_req_data_get;
*swig_req_data_set = *WSO2::WSF::Serverc::wsf_req_info_t_req_data_set;
*swig_req_data_length_get = *WSO2::WSF::Serverc::wsf_req_info_t_req_data_length_get;
*swig_req_data_length_set = *WSO2::WSF::Serverc::wsf_req_info_t_req_data_length_set;
*swig_result_payload_get = *WSO2::WSF::Serverc::wsf_req_info_t_result_payload_get;
*swig_result_payload_set = *WSO2::WSF::Serverc::wsf_req_info_t_result_payload_set;
*swig_result_length_get = *WSO2::WSF::Serverc::wsf_req_info_t_result_length_get;
*swig_result_length_set = *WSO2::WSF::Serverc::wsf_req_info_t_result_length_set;
*swig_transfer_encoding_get = *WSO2::WSF::Serverc::wsf_req_info_t_transfer_encoding_get;
*swig_transfer_encoding_set = *WSO2::WSF::Serverc::wsf_req_info_t_transfer_encoding_set;
*swig_out_content_type_get = *WSO2::WSF::Serverc::wsf_req_info_t_out_content_type_get;
*swig_out_content_type_set = *WSO2::WSF::Serverc::wsf_req_info_t_out_content_type_set;
sub new {
    my $pkg = shift;
    my $self = WSO2::WSF::Serverc::new_wsf_req_info_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        WSO2::WSF::Serverc::delete_wsf_req_info_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package WSO2::WSF::Server;

*WS_NONE = *WSO2::WSF::Serverc::WS_NONE;
*WS_SVC_CLIENT = *WSO2::WSF::Serverc::WS_SVC_CLIENT;
*WS_SVC = *WSO2::WSF::Serverc::WS_SVC;
*WS_FAULT = *WSO2::WSF::Serverc::WS_FAULT;
*WS_PARAM = *WSO2::WSF::Serverc::WS_PARAM;
*WS_OBJECT_LAST = *WSO2::WSF::Serverc::WS_OBJECT_LAST;
*WS_USING_STRING = *WSO2::WSF::Serverc::WS_USING_STRING;
*WS_USING_MSG = *WSO2::WSF::Serverc::WS_USING_MSG;
*WS_USING_INCORRECT_INPUT = *WSO2::WSF::Serverc::WS_USING_INCORRECT_INPUT;
1;
