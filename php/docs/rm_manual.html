<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>WS02 WSF WSDL generation API</title>
  <link href="style/api_style.css" rel="stylesheet" type="text/css" media="all" />
</head>

<body>
<h1> 
   <span style="font-family: Arial;">Reliable Messaging API manual</span></h1>
     <p>   Wsf4php extension supports reliable messaging protocal version 1.0 now.
        For the beta release, both 1.0 and 1.1 will be supported. One way as well as
        two way reliable
         messaging
        is supported using single channel.</p>
    <h2>
        <strong id="1">1.0 How to configure WSO2 WSF/PHP to use reliable messaging</strong></h2>
    <p>
        We assume that you have installed the WSO2 WSF/PHP.
        </p>
    <p>
        To implement reliable messaging wsf-php uses a database system to store state information
        related to messaging and for that two data base systems supported. They are sqlite3
        and mysql.&nbsp;</p>
    <p>
        <strong>Using WSO2 WSF/PHP with sqlite3</strong></p>
    <p>
        you will need to have sqlite3 installed on your machine.
    </p>
    <p>
        Note:- On windows binary , sqlite3 binary and and executable will&nbsp; be packed
        with the WSO2 WSF/PHP binary. So what you will need is to add &lt;WSO2 WSF/PHP&gt;\wsf_c\lib
        directory to path.</p>
    <p>
        You will find a script (sqlite_schema.sh | sqlite_schema.bat )&nbsp; for creating
        the databases that are used by WSO2 WSF/PHP in &lt;WSO2 WSF/PHP&gt; directory. Make sure to
        run
        this script before starting the server. When you run these script, it will create
        two database files "sandesha2_client_db" "sandesha2_svr_db" in the direcory where
        you executed the script. On linux put these databases to your linux environment's
        /tmp directory and these files should have the read write permissions for the user
        that is used to run your server.</p>
    <p>
        On windows add the following php.ini entry.</p>
    <p>
        <strong>
        wsf.rm_db_dir=&lt;database location&gt; </strong>
    </p>
    <p>
        You can do the same on linux if you have provided read write permisions.</p>
    <h2>
       <strong id="2">2.0 Writing a RM Web Service Client.</strong></h2>
    <p>
        Since WS Addressing is needed WSRM to work, you need to specify the necessary WS
        addressing options along with RM Options. Lets implement the simplest rm client
        that can be written using WSO2 WSF/PHP.
    </p>
    <p>
        First create a suitable payload to be send to the echo service.</p>
    <p>
        $req_payload_string =&nbsp; &lt;&lt;&lt;XML &lt;ns1:echoString xmlns="http://www.wsf.org/echo/echoString"&gt;&lt;text&gt;Hello
        RM!&lt;/text&gt;&lt;/ns1:echoString&gt;XML;</p>
    <p>
        try {
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $msg = &nbsp; new WSMessage($reqPayloadString,
        &nbsp;array("<span style="color: #ff6666">action</span>" =&gt; "<span style="color: #ff6666">http://php.axis2.org/samples/echoString</span>")
        );
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $client = new WSClient(array( "<span style="color: #ff6666">to</span>"=&gt;"<span
            style="color: #ff6666">http://localhost/echo_service_rm.php</span>", "<span
                style="color: #ff6666">reliable</span>"=&gt;TRUE));
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $result = $client-&gt;request($msg);
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo $result-&gt;str;</p>
    <p>
        } catch (Exception $e) {&nbsp;</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if ($e instanceof WSFault) {
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; printf("Soap Fault: %s\n",
        $e-&gt;code);
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; printf("Message = %s\n",$e-&gt;getMessage());
        }</p>
    <p>
        }
    </p>
    <p>
        Note that we set the addressing action in WSMessage options and "reliable"=&gt;TRUE
        option in WSClient options to enable RM. Since addressing action
        is present, Addressing will be enabled with "reliable"=&gt;TRUE option. This client
        will create an RM Sequence, send its only application message and terminate the sequence.
    </p>
    <p>
        If you wish to send multiple application messages reliably to the reciving RM Endpoint
        you can configure the above web service client as follows.</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $msg0 = &nbsp; new WSMessage($reqPayloadString,
        &nbsp;array("<span style="color: #ff6666">action</span>" =&gt; "<span style="color: #ff6666">http://php.axis2.org/samples/echoString</span>")
        );
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $msg1 = new WSMessage($reqPayloadString, array("<span
            style="color: #ff6666">action</span>"=&gt;"<span style="color: #ff6666">http://php.axis2.org/samples/echoString</span>"));</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $msg2 = new WSMessage($reqPayloadString, array("<span
            style="color: #ff6666">action</span>"=&gt;"<span style="color: #ff6666">http://php.axis2.org/samples/echoString</span>",
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; "<span style="color: #ff6666">lastMessage</span>"=&gt;TRUE));</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $client = new WSClient(array( "<span style="color: #ff6666">to</span>"=&gt;"<span
            style="color: #ff6666">http://localhost:8080/echo_service_rm.php</span>",
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; "<span style="color: #ff6666">reliable</span>"=&gt;TRUE,</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; "<span style="color: #ff6666">willContinueSequence</span>"=&gt;TRUE));
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $result = $client-&gt;request($msg0);
    </p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $client-&gt;request($msg1);</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $client-&gt;request($msg2);</p>
    <p>
        Since we specified "willContinueSequence"=&gt;TRUE option in WSClient , It will
        not terminate the sequence after sending the first message. It keeps the
        sequence open till a default sequenceExpiryTime. You can configure this value using
        "sequenceExpiryTime" option in WSClient. So we send the $msg2 using the currently
        opened sequence. On $msg3 we specify that this will be the last message that will
        be sent using the current sequence using the option "lastMessage"=&gt;TRUE. Now
        WSClient will terminate the current sequence after sending $msg2.</p>
    <p>
       </p>
       <h2><strong id="3">3.0 Writing a&nbsp; RM Web Service</strong></h2>
    <p>
        Following code demostrate how to write an rm Web Service client. This echo_service_rm.php
        was used as the above client's receiving endpoint.</p>
    <p>
        function echoFunction($inMessage){</p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return new WSMessage($inMessage-&gt;str);</p>
    <p>
        }</p>
    <p>
        $operations = array("<span style="color: #ff6666">echoString</span>" =&gt; "<span
            style="color: #ff6666">echoFunction</span>");</p>
    <p>
        $actions &nbsp; &nbsp;&nbsp; = array("<span style="color: #ff6666">http://php.axis2.org/samples/echoString</span>"=&gt;"<span
            style="color: #ff6666">echoString</span>");</p>
    <p>
        $service = new WSService(array("<span style="color: #ff6666">operations</span>"=&gt;<span
            style="color: #ff6666">$operations,</span></p>
    <p>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
        "<span style="color: #ff6666">reliable</span>"=&gt;TRUE));</p>
    <p>
        $service-&gt;reply();</p>
    <p>
        Note how we map "echoString" operation to "http://php.axis2.org/samples/echoString"&nbsp;
        which is the same action uri used in above eample client.</p>
    <p>
        On WSService options, "reliable"=&gt;TRUE option is used to tell the service to
        use RM protocol.</p>
    <p>
        &nbsp;</p>
</body>
</html>
